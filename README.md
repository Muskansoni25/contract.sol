# contract.sol
This is a basic example, but it demonstrates the different purposes of require(), assert(), and revert() in handling errors and ensuring proper smart contract behavior. 
require(): This statement is used to check conditions that are essential for the contract's functionality. If the condition fails, the transaction is reverted, and any gas used is refunded. In the setValue function, require ensures the new value is greater than 100 before updating the state variable value.
assert(): This statement is used to check internal invariants, which are assumptions the code relies on being true at all times. If an assertion fails, the transaction is also reverted, but unlike require, assertions are meant for catching unexpected errors during development and testing. In the internalCheck function, assert checks if value is always greater than 0 (an invariant we establish for this example). This assertion would typically be removed before deployment.
revert(): This statement can be used explicitly to revert a transaction. It's less common than require as it offers less flexibility in terms of error messages. In the forceFail function, we deliberately set value to 0, which would fail the assertion in internalCheck. However, instead of relying on the assertion to revert, we can explicitly use revert() to showcase its usage.
